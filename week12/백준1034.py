###############################################################################
# 1. 모든 경우의 수: 50^1000 -> Brute Force는 불가능
# 2. DP활용 -> Bitmask -> 메모리 부족
# 3. DP활용 다른방법?
# 4. 각 열은 2가지 상태만 존재한다는 사실 이용 (V)
#   - 짝수번 선택 -> 1이 켜진 상태
#   - 홀수번 선택 -> 0이 켜진 상태
#     1) 2^50가지 경우의 수 활용 -> 불가능
#     2) 조합이용 -> 2^25가지 경우의 수 활용 -> 불가능
#       - 짝수를 짝수번 더하기 = 짝수 (1이 켜진상태인 열이 홀수개 존재)
#       - 짝수를 홀수번 더하기 = 짝수 (1이 켜진상태인 열이 홀수개 존재)
#       - 홀수를 짝수번 더하기 = 짝수 (1이 켜진상태인 열이 짝수개 존재)
#       - 홀수를 홀수번 더하기 = 홀수 (0이 켜진상태인 열이 홀수개 존재)
# 5. 각 행별로 전부 켜지도록 변화시켜가며 가장 큰 수 결정 -> 50가지 경우의 수
#   - 모든 행에 대해 적용해 보면 모든 경우의 수를 생각할 수 있음! 
###############################################################################

# N, M <= 50인 자연수
N, M = map(int, input().split())
MAP = []
dic = {}
for i in range(N):
  MAP.append(input())
  if MAP[i] in dic:
    dic[MAP[i]] += 1
  else:
    dic.update({MAP[i] : 1})

# k <= 1000인 자연수
K = int(input())

num = 0
for key, value in dic.items():
  # 바꿔야 하는 열이 짝수일 경우 K는 짝수여야 함
  # 바꿔야 하는 열이 홀수일 경우 K는 홀수여야 함
  zero = key.count('0')
  if zero % 2 == 0 and K % 2 == 1: continue
  if zero % 2 == 1 and K % 2 == 0: continue
  if zero > K:                     continue
  # 해당 패턴의 행(key)에 대해 전부 불을 킬 수 있는 경우
  if value > num:
    num = value

print(num)